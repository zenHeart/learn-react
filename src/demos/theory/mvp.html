<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>React MVP</title>
</head>
<body>
  <div id="root"></div>
  <script>
    // Create React Element (Virtual DOM node)
    function createReactElement(type, props, ...children) {
      return {
        type,
        props: {
          ...props,
          children: children.map(child =>
            typeof child === 'object' ? child : createTextElement(child)
          ),
        },
      };
    }

    function createTextElement(text) {
      return {
        type: 'TEXT_ELEMENT',
        props: {
          nodeValue: text,
          children: [],
        },
      };
    }

    // Global variables to track work
    let nextUnitOfWork = null;
    let currentRoot = null;
    let wipRoot = null;
    let deletions = null;

    function createRoot(container) {
      return {
        render(element) {
          wipRoot = {
            dom: container,
            props: {
              children: [element],
            },
            alternate: currentRoot,
          };
          deletions = [];
          nextUnitOfWork = wipRoot;
        },
      };
    }

    function workLoop(deadline) {
      let shouldYield = false;
      
      while (nextUnitOfWork && !shouldYield) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        shouldYield = deadline.timeRemaining() < 1;
      }

      // If we finished all work, commit the root
      if (!nextUnitOfWork && wipRoot) {
        commitRoot();
      }

      requestIdleCallback(workLoop);
    }

    function commitRoot() {
      // First handle deletions
      deletions.forEach(commitWork);
      // Then commit the new/updated nodes
      commitWork(wipRoot.child);
      currentRoot = wipRoot;
      wipRoot = null;
    }

    function commitWork(fiber) {
      if (!fiber) {
        return;
      }

      // Find the nearest parent with a DOM node
      let domParentFiber = fiber.parent;
      while (domParentFiber && !domParentFiber.dom) {
        domParentFiber = domParentFiber.parent;
      }
      const domParent = domParentFiber.dom;

      // Handle DOM operations based on effect tag
      if (fiber.dom) {
        domParent.appendChild(fiber.dom);
      }

      // Recursively commit children and siblings
      commitWork(fiber.child);
      commitWork(fiber.sibling);
    }

    function performUnitOfWork(fiber) {
      const isFunctionComponent = typeof fiber.type === 'function';

      if (isFunctionComponent) {
        updateFunctionComponent(fiber);
      } else {
        updateHostComponent(fiber);
      }

      // Return next unit of work
      if (fiber.child) {
        return fiber.child;
      }

      let nextFiber = fiber;
      while (nextFiber) {
        if (nextFiber.sibling) {
          return nextFiber.sibling;
        }
        nextFiber = nextFiber.parent;
      }
    }

    function updateFunctionComponent(fiber) {
      // Execute the function component to get its children
      const children = [fiber.type(fiber.props)];
      reconcileChildren(fiber, children);
    }

    function updateHostComponent(fiber) {
      // Create DOM node if it doesn't exist
      if (!fiber.dom) {
        fiber.dom = createDom(fiber);
      }
      // Reconcile children
      reconcileChildren(fiber, fiber.props.children);
    }

    function createDom(fiber) {
      const dom =
        fiber.type === 'TEXT_ELEMENT'
          ? document.createTextNode('')
          : document.createElement(fiber.type);

      updateDom(dom, {}, fiber.props);
      return dom;
    }

    function updateDom(dom, prevProps, nextProps) {
      // Handle regular props
      const isProperty = key => key !== 'children';
      
      // Remove old properties
      Object.keys(prevProps)
        .filter(isProperty)
        .forEach(name => {
          if (!(name in nextProps)) {
            dom[name] = '';
          }
        });

      // Set new or changed properties
      Object.keys(nextProps)
        .filter(isProperty)
        .forEach(name => {
          if (prevProps[name] !== nextProps[name]) {
            if (name === 'nodeValue') {
              dom.textContent = nextProps[name];
            } else {
              dom[name] = nextProps[name];
            }
          }
        });
    }

    function reconcileChildren(wipFiber, elements) {
      let index = 0;
      let oldFiber = wipFiber.alternate && wipFiber.alternate.child;
      let prevSibling = null;

      while (index < elements.length || oldFiber) {
        const element = elements[index];
        let newFiber = null;

        // Create new fiber
        if (element) {
          newFiber = {
            type: element.type,
            props: element.props,
            parent: wipFiber,
            dom: null,
            alternate: oldFiber,
            effectTag: 'PLACEMENT',
          };
        }

        // Link the fibers
        if (index === 0) {
          wipFiber.child = newFiber;
        } else if (element && prevSibling) {
          prevSibling.sibling = newFiber;
        }

        oldFiber = oldFiber?.sibling;
        prevSibling = newFiber;
        index++;
      }
    }

    // Start the render loop
    requestIdleCallback(workLoop);

    // Example App component
    function App() {
      return createReactElement(
        'div',
        { style: 'padding: 20px;' },
        createReactElement('h1', { style: 'color: blue;' }, 'Hello from React MVP!'),
        createReactElement('p', null, 'This is a working implementation'),
        createReactElement('button', 
          { onclick: () => alert('Button clicked!') }, 
          'Click me!'
        )
      );
    }

    // Initialize the app
    const container = document.getElementById('root');
    const root = createRoot(container);
    root.render(createReactElement(App));
  </script>
</body>
</html>